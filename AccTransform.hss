flatten-module

set-pp-type Omit

rhs-of 'main

one-td (unfold-rule "Acc-Start"); assume

{
  application-of 'inline
  app-fun; app-arg
  inline
}
one-td (unfold-rule "inline-elim"); assume

one-td (beta-reduce >>> let-subst)

repeat (one-td (unfold-rule "==*-intro")); assume
repeat (one-td (unfold-rule "+-intro")); assume
repeat (one-td (unfold-rule "*-intro")); assume
repeat (one-td (unfold-rule "quot-intro")); assume
repeat (one-td (unfold-rule "even-intro")); assume

  -- Get rid of dictionary lets
repeat (one-td (beta-reduce >>> let-subst))
repeat (one-td let-subst)

try (repeat (one-td let-float-app))

  -- Bring 'abs' into let body
one-td let-float-arg

  -- Recursive transformation --
one-td fix-intro

{
  application-of 'fix
  app-arg
  let-intro '__REC_FUN__
  up; up
  one-td let-float
}

-- {
--   application-of 'fix
--   up; up; up
--   let-subst
-- }


  -- Bring function body in
{
  application-of 'annotate  -- Find Start annotation
  app-arg
  let-subst
}

repeat (one-td let-float-app)
repeat (one-td let-float-arg)

one-td (unfold-rule "fix-abs-rep-intro"); assume
one-td (unfold-rule "RecCall-intro"); assume

repeat (one-td (unfold '.))
repeat (one-td (beta-reduce >>> let-subst))
one-td case-elim

stop-script
-- repeat (one-td (beta-reduce >>> let-subst))
-- one-td (forward fix-computation-rule)


{
  -- Unfold the inner function then perform transformation to 'cond'
  -- and eliminate base case
  -- application-of 'fix
  occurrence-of '$WRecursive
  up; up
  one-td (unfold '__REC_FUN__)


  -- float abs into non-Bool cases while also transforming Bool cases to cond
  repeat (one-td (unfold-rule "abs-if->cond" <+ case-float-arg-lemma "case-float-lemma" )); assume; assume

  repeat (one-td (beta-reduce >>> let-subst))
  one-td (unfold-rule "cond-RecCondF"); assume

}

